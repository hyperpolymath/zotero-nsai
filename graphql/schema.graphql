# NSAI GraphQL Schema
# Neurosymbolic AI Integration API
# Version: 2.0.0-neurosymbolic

"""
NSAI GraphQL API provides integration points for:
- Citation validation (Tractarian logic)
- Fogbinder handoff (uncertainty exploration)
- OpenCyc knowledge integration
- Reservoir computing
- Conceptor frameworks
- Expert systems
- Liquid state machines
- Agentic AI systems
- Neural-symbolic reasoning
"""

# ============================================================================
# CORE TYPES: Citation Validation
# ============================================================================

"""
Atomic citation following Tractarian logic.
Citations are atomic facts with logical structure.
"""
type AtomicCitation {
  id: ID!
  itemType: ItemType!
  title: String!
  creators: [Creator!]!
  date: String
  publisher: String
  doi: String
  isbn: String
  url: String
  abstractNote: String
  tags: [String!]!
  extra: String

  """Validation state (computed)"""
  validationState: ValidationState

  """Certainty score (0.0-1.0)"""
  certainty: CertaintyScore

  """Connected knowledge from OpenCyc"""
  cycConcepts: [CycConcept!]
}

enum ItemType {
  BOOK
  BOOK_SECTION
  JOURNAL_ARTICLE
  CONFERENCE_PAPER
  THESIS
  WEBPAGE
  MANUSCRIPT
  REPORT
  PATENT
}

type Creator {
  creatorType: CreatorType!
  firstName: String
  lastName: String!
}

enum CreatorType {
  AUTHOR
  EDITOR
  CONTRIBUTOR
  TRANSLATOR
}

enum ValidationState {
  VALID
  INCOMPLETE
  INCONSISTENT
  UNCERTAIN
}

type CertaintyScore {
  score: Float!
  factors: CertaintyFactors!
  reasoning: String!
}

type CertaintyFactors {
  structural: Float!
  consistency: Float!
  referential: Float!
}

type ValidationIssue {
  severity: Severity!
  field: String
  message: String!
  suggestion: String
  requiresUncertaintyNavigation: Boolean!
}

enum Severity {
  ERROR
  WARNING
  INFO
}

# ============================================================================
# FOGBINDER INTEGRATION
# ============================================================================

"""
Fogbinder handoff for uncertainty exploration.
The NSAIâ†’Fogbinder boundary at the certainty threshold.
"""
type FogbinderPayload {
  version: String!
  timestamp: DateTime!
  validatedCitations: [ValidatedCitation!]!
  invalidCitations: [InvalidCitation!]!
  uncertaintyRegions: [UncertaintyRegion!]!
  contradictionHints: [ContradictionHint!]!
  epistemicSummary: EpistemicSummary!
}

type ValidatedCitation {
  citation: AtomicCitation!
  certainty: Float!
  certainties: [String!]!
}

type InvalidCitation {
  citation: AtomicCitation!
  reason: String!
  uncertainties: [String!]!
}

type UncertaintyRegion {
  id: ID!
  type: UncertaintyType!
  citationIds: [ID!]!
  description: String!
  uncertaintyLevel: Float!
  suggestedExploration: ExplorationSuggestion!
}

enum UncertaintyType {
  STRUCTURAL
  SEMANTIC
  RELATIONAL
  TEMPORAL
}

type ExplorationSuggestion {
  useContradictionDetection: Boolean
  useMoodScoring: Boolean
  useMysteryClustering: Boolean
  useFogTrailVisualization: Boolean
}

type ContradictionHint {
  citationA: ID!
  citationB: ID!
  type: ContradictionType!
  description: String!
  confidence: Float!
  requiresSemanticAnalysis: Boolean!
}

enum ContradictionType {
  METADATA
  TEMPORAL
  AUTHORSHIP
  SEMANTIC_HINT
}

type EpistemicSummary {
  totalCitations: Int!
  validatedCount: Int!
  uncertainCount: Int!
  overallCertainty: Float!
  epistemicGaps: [EpistemicGap!]!
  recommendation: String!
}

type EpistemicGap {
  type: GapType!
  severity: Severity!
  description: String!
  suggestion: String!
  explorableInFogbinder: Boolean!
}

enum GapType {
  MISSING_CITATIONS
  INCOMPLETE_METADATA
  TEMPORAL_GAP
  CONTRADICTORY_CLAIMS
  AMBIGUOUS_SOURCES
}

# ============================================================================
# OPENCYC INTEGRATION
# ============================================================================

"""
OpenCyc knowledge base integration.
Polls OpenCyc for concept enrichment and reasoning.
"""
type CycConcept {
  id: ID!
  name: String!
  comment: String
  isa: [CycConcept!]!
  genls: [CycConcept!]!

  """Related concepts by similarity"""
  related: [CycConcept!]!

  """Assertions about this concept"""
  assertions: [CycAssertion!]!

  """How this concept relates to the citation"""
  citationRelevance: Float!
}

type CycAssertion {
  id: ID!
  predicate: String!
  subject: CycConcept!
  object: CycConcept
  truth: Boolean!
  confidence: Float!
}

"""
OpenCyc query result
"""
type CycQueryResult {
  query: String!
  results: [CycConcept!]!
  confidence: Float!
  reasoning: String
}

# ============================================================================
# RESERVOIR COMPUTING
# ============================================================================

"""
Reservoir computing integration for temporal pattern recognition.
Echo State Networks (ESN) and Liquid State Machines (LSM).
"""
type ReservoirComputer {
  id: ID!
  name: String!
  type: ReservoirType!

  """Reservoir size (number of neurons)"""
  size: Int!

  """Spectral radius (stability parameter)"""
  spectralRadius: Float!

  """Input scaling"""
  inputScaling: Float!

  """Current reservoir state"""
  state: [Float!]!

  """Trained readout weights"""
  readoutWeights: [[Float!]!]
}

enum ReservoirType {
  ECHO_STATE_NETWORK
  LIQUID_STATE_MACHINE
  CONCEPTOR
}

"""
Reservoir training result
"""
type ReservoirTrainingResult {
  reservoir: ReservoirComputer!
  trainingError: Float!
  validationError: Float!
  epochs: Int!
  converged: Boolean!
}

"""
Reservoir prediction from citation sequence
"""
type ReservoirPrediction {
  prediction: [Float!]!
  confidence: Float!
  nextCitationSuggestion: AtomicCitation
  temporalPattern: String
}

# ============================================================================
# CONCEPTORS
# ============================================================================

"""
Conceptor framework (Herbert Jaeger) for pattern abstraction.
Conceptors learn abstract patterns from reservoir states.
"""
type Conceptor {
  id: ID!
  name: String!

  """Conceptor matrix (compressed reservoir state pattern)"""
  matrix: [[Float!]!]!

  """Aperture (abstraction level)"""
  aperture: Float!

  """Quota (resource allocation)"""
  quota: Float!

  """Evidence (how much data supports this pattern)"""
  evidence: Float!
}

"""
Conceptor logic operations
"""
type ConceptorLogic {
  """AND operation (intersection of patterns)"""
  and(a: ID!, b: ID!): Conceptor!

  """OR operation (union of patterns)"""
  or(a: ID!, b: ID!): Conceptor!

  """NOT operation (negation of pattern)"""
  not(c: ID!): Conceptor!

  """Abstraction (increase aperture)"""
  abstract(c: ID!, newAperture: Float!): Conceptor!
}

"""
Conceptor pattern match result
"""
type ConceptorMatch {
  conceptor: Conceptor!
  matchScore: Float!
  explanation: String!
  suggestedCitations: [AtomicCitation!]!
}

# ============================================================================
# EXPERT SYSTEMS
# ============================================================================

"""
Expert system integration for rule-based reasoning.
Forward/backward chaining inference engines.
"""
type ExpertSystem {
  id: ID!
  name: String!
  domain: String!

  """Knowledge base (rules + facts)"""
  rules: [Rule!]!
  facts: [Fact!]!

  """Inference engine type"""
  engineType: InferenceEngine!

  """Confidence threshold for firing rules"""
  confidenceThreshold: Float!
}

type Rule {
  id: ID!
  name: String!

  """IF conditions"""
  conditions: [Condition!]!

  """THEN actions"""
  actions: [Action!]!

  """Rule priority (for conflict resolution)"""
  priority: Int!

  """Rule confidence"""
  confidence: Float!
}

type Condition {
  predicate: String!
  subject: String!
  object: String
  operator: ConditionOperator!
}

enum ConditionOperator {
  EQUALS
  NOT_EQUALS
  GREATER_THAN
  LESS_THAN
  CONTAINS
  MATCHES_PATTERN
}

type Action {
  type: ActionType!
  target: String!
  value: String
}

enum ActionType {
  ASSERT_FACT
  RETRACT_FACT
  SUGGEST_CITATION
  FLAG_UNCERTAINTY
  INVOKE_FOGBINDER
}

type Fact {
  predicate: String!
  subject: String!
  object: String
  confidence: Float!
  source: String
}

enum InferenceEngine {
  FORWARD_CHAINING
  BACKWARD_CHAINING
  HYBRID
}

"""
Expert system query result
"""
type ExpertSystemResult {
  query: String!
  matchedRules: [Rule!]!
  derivedFacts: [Fact!]!
  confidence: Float!
  explanation: String!
  suggestedActions: [Action!]!
}

# ============================================================================
# LIQUID STATE MACHINES
# ============================================================================

"""
Liquid State Machine (LSM) - spiking neural network reservoir.
Processes spatiotemporal patterns in citation data.
"""
type LiquidStateMachine {
  id: ID!
  name: String!

  """Number of spiking neurons in reservoir"""
  neuronCount: Int!

  """Synaptic connections"""
  synapses: [Synapse!]!

  """Current spike train"""
  spikeTrain: [[Float!]!]!

  """Membrane potentials"""
  membranePotentials: [Float!]!

  """Readout layer"""
  readout: [[Float!]!]!
}

type Synapse {
  source: Int!
  target: Int!
  weight: Float!
  delay: Float!
}

"""
LSM spike encoding for citation features
"""
type SpikeEncoding {
  feature: String!
  spikeTimes: [Float!]!
  encoding: EncodingType!
}

enum EncodingType {
  RATE_CODING
  TEMPORAL_CODING
  POPULATION_CODING
  BURST_CODING
}

"""
LSM prediction result
"""
type LSMPrediction {
  classification: String!
  confidence: Float!
  spikePattern: String!
  temporalFeatures: [String!]!
}

# ============================================================================
# AGENTIC SYSTEMS
# ============================================================================

"""
Agentic AI system integration.
Goal-oriented autonomous agents for research assistance.
"""
type Agent {
  id: ID!
  name: String!
  type: AgentType!

  """Current goal"""
  goal: Goal

  """Agent's beliefs (world model)"""
  beliefs: [Belief!]!

  """Available actions"""
  actions: [AgentAction!]!

  """Planning strategy"""
  planner: Planner!

  """Learning mechanism"""
  learner: Learner
}

enum AgentType {
  REACTIVE
  DELIBERATIVE
  HYBRID
  BDI
  GOAL_ORIENTED
}

type Goal {
  id: ID!
  description: String!
  priority: Int!
  deadline: DateTime
  subgoals: [Goal!]!
  achieved: Boolean!
}

type Belief {
  predicate: String!
  confidence: Float!
  source: String!
  timestamp: DateTime!
}

type AgentAction {
  id: ID!
  name: String!
  preconditions: [Condition!]!
  effects: [Effect!]!
  cost: Float!
}

type Effect {
  predicate: String!
  change: String!
}

type Planner {
  type: PlannerType!
  horizon: Int!
}

enum PlannerType {
  STRIPS
  HTN
  POMDP
  MCTS
  REINFORCEMENT_LEARNING
}

type Learner {
  type: LearnerType!
  explorationRate: Float!
  learningRate: Float!
}

enum LearnerType {
  Q_LEARNING
  DEEP_Q_NETWORK
  POLICY_GRADIENT
  ACTOR_CRITIC
  MODEL_BASED
}

"""
Agent plan execution result
"""
type AgentPlanResult {
  plan: [AgentAction!]!
  expectedUtility: Float!
  executionTrace: [String!]!
  success: Boolean!
  learningUpdate: String
}

# ============================================================================
# NEURAL-SYMBOLIC INTEGRATION
# ============================================================================

"""
Neural-symbolic integration layer.
Combines neural networks with symbolic reasoning.
"""
type NeuralSymbolicSystem {
  id: ID!
  name: String!

  """Neural component (e.g., embedding network)"""
  neuralNetwork: NeuralNetwork!

  """Symbolic component (e.g., logic program)"""
  symbolicReasoner: SymbolicReasoner!

  """Integration method"""
  integration: IntegrationType!
}

type NeuralNetwork {
  id: ID!
  architecture: String!
  layers: [Layer!]!
  trained: Boolean!
  accuracy: Float
}

type Layer {
  type: LayerType!
  size: Int!
  activation: ActivationType
}

enum LayerType {
  INPUT
  DENSE
  CONV
  RECURRENT
  ATTENTION
  EMBEDDING
  OUTPUT
}

enum ActivationType {
  RELU
  SIGMOID
  TANH
  SOFTMAX
  LINEAR
}

type SymbolicReasoner {
  id: ID!
  type: SymbolicType!
  rules: [String!]!
  facts: [String!]!
}

enum SymbolicType {
  PROLOG
  DATALOG
  ANSWER_SET_PROGRAMMING
  DESCRIPTION_LOGIC
  FIRST_ORDER_LOGIC
}

enum IntegrationType {
  NEURAL_GUIDES_SYMBOLIC
  SYMBOLIC_GUIDES_NEURAL
  JOINT_TRAINING
  DEEPPROBLOG
  LOGIC_TENSOR_NETWORKS
}

"""
Neural-symbolic inference result
"""
type NeuralSymbolicInference {
  neuralOutput: [Float!]!
  symbolicDerivation: String!
  combinedConfidence: Float!
  explanation: String!
}

# ============================================================================
# QUERIES
# ============================================================================

type Query {
  # Citation validation
  validateCitation(citation: AtomicCitationInput!): ValidationResult!
  validateBatch(citations: [AtomicCitationInput!]!): [ValidationResult!]!
  getCitation(id: ID!): AtomicCitation
  searchCitations(query: String!): [AtomicCitation!]!

  # Fogbinder integration
  createFogbinderPayload(citationIds: [ID!]!): FogbinderPayload!
  getCertaintyBoundary(citationIds: [ID!]!): CertaintyBoundary!

  # OpenCyc integration
  queryCyc(query: String!): CycQueryResult!
  getCycConcept(id: ID!): CycConcept
  enrichCitationWithCyc(citationId: ID!): AtomicCitation!

  # Reservoir computing
  getReservoir(id: ID!): ReservoirComputer
  predictNextCitation(reservoirId: ID!, sequence: [ID!]!): ReservoirPrediction!

  # Conceptors
  getConceptor(id: ID!): Conceptor
  matchConceptor(pattern: [Float!]!): ConceptorMatch!

  # Expert systems
  getExpertSystem(id: ID!): ExpertSystem
  queryExpertSystem(systemId: ID!, query: String!): ExpertSystemResult!

  # Liquid state machines
  getLSM(id: ID!): LiquidStateMachine
  classifyWithLSM(lsmId: ID!, input: [Float!]!): LSMPrediction!

  # Agentic systems
  getAgent(id: ID!): Agent
  planWithAgent(agentId: ID!, goal: GoalInput!): AgentPlanResult!

  # Neural-symbolic
  getNeuralSymbolicSystem(id: ID!): NeuralSymbolicSystem
  inferNeuralSymbolic(systemId: ID!, input: NeuralSymbolicInput!): NeuralSymbolicInference!
}

# ============================================================================
# MUTATIONS
# ============================================================================

type Mutation {
  # Citation management
  createCitation(input: AtomicCitationInput!): AtomicCitation!
  updateCitation(id: ID!, input: AtomicCitationInput!): AtomicCitation!
  deleteCitation(id: ID!): Boolean!

  # Reservoir computing
  createReservoir(input: ReservoirInput!): ReservoirComputer!
  trainReservoir(reservoirId: ID!, trainingData: [[Float!]!]!): ReservoirTrainingResult!

  # Conceptors
  learnConceptor(reservoirId: ID!, pattern: [Float!]!, aperture: Float!): Conceptor!

  # Expert systems
  createExpertSystem(input: ExpertSystemInput!): ExpertSystem!
  addRule(systemId: ID!, rule: RuleInput!): Rule!
  assertFact(systemId: ID!, fact: FactInput!): Fact!

  # LSM
  createLSM(input: LSMInput!): LiquidStateMachine!
  trainLSM(lsmId: ID!, trainingData: [SpikeEncodingInput!]!): LSMTrainingResult!

  # Agents
  createAgent(input: AgentInput!): Agent!
  setGoal(agentId: ID!, goal: GoalInput!): Agent!
  executeAction(agentId: ID!, actionId: ID!): AgentActionResult!

  # Neural-symbolic
  createNeuralSymbolicSystem(input: NeuralSymbolicInput!): NeuralSymbolicSystem!
  trainNeuralSymbolic(systemId: ID!, trainingData: [TrainingExample!]!): TrainingResult!
}

# ============================================================================
# SUBSCRIPTIONS
# ============================================================================

type Subscription {
  # Real-time validation updates
  validationProgress(batchId: ID!): ValidationProgress!

  # Reservoir state updates
  reservoirState(reservoirId: ID!): [Float!]!

  # Agent execution updates
  agentProgress(agentId: ID!): AgentProgress!

  # LSM spike events
  lsmSpikes(lsmId: ID!): SpikeEvent!

  # OpenCyc query results (streaming)
  cycQueryStream(query: String!): CycConcept!
}

# ============================================================================
# INPUT TYPES
# ============================================================================

input AtomicCitationInput {
  itemType: ItemType!
  title: String!
  creators: [CreatorInput!]!
  date: String
  publisher: String
  doi: String
  isbn: String
  url: String
  abstractNote: String
  tags: [String!]
  extra: String
}

input CreatorInput {
  creatorType: CreatorType!
  firstName: String
  lastName: String!
}

input ReservoirInput {
  name: String!
  type: ReservoirType!
  size: Int!
  spectralRadius: Float
  inputScaling: Float
}

input ExpertSystemInput {
  name: String!
  domain: String!
  engineType: InferenceEngine!
}

input RuleInput {
  name: String!
  conditions: [ConditionInput!]!
  actions: [ActionInput!]!
  priority: Int
  confidence: Float
}

input ConditionInput {
  predicate: String!
  subject: String!
  object: String
  operator: ConditionOperator!
}

input ActionInput {
  type: ActionType!
  target: String!
  value: String
}

input FactInput {
  predicate: String!
  subject: String!
  object: String
  confidence: Float
  source: String
}

input LSMInput {
  name: String!
  neuronCount: Int!
}

input SpikeEncodingInput {
  feature: String!
  spikeTimes: [Float!]!
  encoding: EncodingType!
}

input AgentInput {
  name: String!
  type: AgentType!
  plannerType: PlannerType!
  learnerType: LearnerType
}

input GoalInput {
  description: String!
  priority: Int
  deadline: DateTime
}

input NeuralSymbolicInput {
  neuralArchitecture: String!
  symbolicType: SymbolicType!
  integrationType: IntegrationType!
}

input TrainingExample {
  input: [Float!]!
  output: [Float!]!
  symbolicConstraint: String
}

# ============================================================================
# UTILITY TYPES
# ============================================================================

type ValidationResult {
  citation: AtomicCitation!
  state: ValidationState!
  certainty: CertaintyScore!
  issues: [ValidationIssue!]!
  timestamp: DateTime!
}

type CertaintyBoundary {
  validated: [String!]!
  beyondValidation: [String!]!
  handoffRecommendation: String!
}

type ValidationProgress {
  completed: Int!
  total: Int!
  currentCitation: AtomicCitation
  errors: [String!]!
}

type AgentProgress {
  currentAction: AgentAction
  completedActions: Int!
  totalActions: Int!
  status: String!
}

type SpikeEvent {
  neuronId: Int!
  time: Float!
  voltage: Float!
}

type LSMTrainingResult {
  lsm: LiquidStateMachine!
  accuracy: Float!
  epochs: Int!
  converged: Boolean!
}

type AgentActionResult {
  success: Boolean!
  effects: [Effect!]!
  newBeliefs: [Belief!]!
}

type TrainingResult {
  neuralAccuracy: Float!
  symbolicConsistency: Float!
  epochs: Int!
  converged: Boolean!
}

scalar DateTime
