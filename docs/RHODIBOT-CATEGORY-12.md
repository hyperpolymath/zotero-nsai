# Rhodibot Category 12: Language Policy Enforcement

## Overview

Category 12 enforces repository language policy, preventing contamination from banned languages and ensuring compliance with project-specific technology stacks.

## Rationale

Language drift is a critical compliance issue:
- TypeScript creeping into ReScript projects
- npm artifacts appearing in Deno projects
- Python dependencies in Guile-preferred toolchains

Without enforcement, AI assistants and contributors may introduce banned languages, breaking architectural invariants.

## Specification

### 12.1 Banned Language Detection

**MUST** detect and reject the following by default:

```yaml
banned_extensions:
  - .ts           # TypeScript
  - .tsx          # TypeScript JSX
  - .coffee       # CoffeeScript
  - .go           # Go

banned_files:
  - package.json       # npm
  - package-lock.json  # npm lock
  - yarn.lock          # Yarn
  - tsconfig.json      # TypeScript config
  - tslint.json        # TSLint
  - .npmrc             # npm config

conditional_ban:
  - pattern: "*.py"
    unless: "salt/*"   # Python allowed only in Salt directories
```

### 12.2 Allowed Language Declaration

Projects **MAY** declare allowed languages in `.rhodibot.ncl` (Nickel) or `.rhodibot.scm` (Guile):

```nickel
# .rhodibot.ncl
{
  language_policy = {
    allowed = ["rescript", "guile", "rust", "elixir", "lean4", "julia", "scss", "cue", "shell"],
    banned = ["typescript", "coffeescript", "go", "npm"],
    exceptions = [
      { pattern = "*.py", context = "salt/*", reason = "Salt automation" }
    ]
  }
}
```

```scheme
;; .rhodibot.scm
(language-policy
  (allowed rescript guile rust elixir lean4 julia scss cue shell)
  (banned typescript coffeescript go npm)
  (exceptions
    ((pattern . "*.py") (context . "salt/*") (reason . "Salt automation"))))
```

### 12.3 Enforcement Levels

| Level | Behavior |
|-------|----------|
| `strict` | Block PR, fail CI, refuse commit |
| `warn` | Allow but flag in compliance report |
| `audit` | Log only, no enforcement |

Default: `strict`

### 12.4 CI Integration

```yaml
# .github/workflows/rhodibot.yml
- name: Rhodibot Language Policy
  uses: hyperpolymath/rhodibot-action@v1
  with:
    categories: [12]
    level: strict
```

### 12.5 Pre-commit Hook

```bash
#!/bin/sh
# .githooks/pre-commit (generated by rhodibot)
exec rhodibot check --category 12 --staged-only
```

### 12.6 Compliance Badge

```
![Language Policy](https://rhodibot.hyperpolymath.dev/badge/hyperpolymath/zotero-nsai/12)
```

Displays: `Lang Policy: Compliant` or `Lang Policy: Violations`

### 12.7 Error Messages

```
RHODIBOT Category 12 VIOLATION: Language Policy

  ✗ Found banned file: src/index.ts (TypeScript)
  ✗ Found banned file: package.json (npm)

  Project language policy:
    Allowed: ReScript, Guile, Rust, SCSS
    Banned: TypeScript, npm, Go

  To fix:
    - Convert TypeScript to ReScript
    - Replace package.json with deno.json
    - Run: rhodibot fix --category 12

  Documentation: https://rsr.hyperpolymath.dev/categories/12
```

### 12.8 Auto-fix Capabilities

`rhodibot fix --category 12` can:
- Remove empty banned files
- Suggest equivalent allowed-language alternatives
- Generate migration checklist

Cannot auto-convert code (too risky).

## Elixir Implementation

```elixir
defmodule Rhodibot.Categories.LanguagePolicy do
  @moduledoc "Category 12: Language Policy Enforcement"

  @behaviour Rhodibot.Category

  @default_banned_extensions ~w(.ts .tsx .coffee .go)
  @default_banned_files ~w(package.json package-lock.json yarn.lock tsconfig.json)

  @impl true
  def id, do: 12

  @impl true
  def name, do: "Language Policy"

  @impl true
  def check(repo_path, opts \\ []) do
    config = load_config(repo_path) || default_config()
    level = Keyword.get(opts, :level, :strict)

    violations =
      find_banned_extensions(repo_path, config) ++
      find_banned_files(repo_path, config)

    case {violations, level} do
      {[], _} ->
        {:ok, %{status: :compliant, message: "Language policy compliant"}}

      {v, :strict} ->
        {:error, %{status: :violation, violations: v}}

      {v, :warn} ->
        {:warn, %{status: :warning, violations: v}}

      {v, :audit} ->
        {:ok, %{status: :audit, violations: v}}
    end
  end

  defp load_config(repo_path) do
    nickel_path = Path.join(repo_path, ".rhodibot.ncl")
    scheme_path = Path.join(repo_path, ".rhodibot.scm")

    cond do
      File.exists?(nickel_path) -> parse_nickel(nickel_path)
      File.exists?(scheme_path) -> parse_scheme(scheme_path)
      true -> nil
    end
  end

  defp default_config do
    %{
      banned_extensions: @default_banned_extensions,
      banned_files: @default_banned_files,
      exceptions: []
    }
  end

  defp find_banned_extensions(repo_path, config) do
    config.banned_extensions
    |> Enum.flat_map(fn ext ->
      Path.wildcard(Path.join(repo_path, "**/*#{ext}"))
      |> Enum.reject(&matches_exception?(&1, config.exceptions))
      |> Enum.map(&{:banned_extension, ext, &1})
    end)
  end

  defp find_banned_files(repo_path, config) do
    config.banned_files
    |> Enum.filter(&File.exists?(Path.join(repo_path, &1)))
    |> Enum.map(&{:banned_file, &1, Path.join(repo_path, &1)})
  end

  defp matches_exception?(path, exceptions) do
    Enum.any?(exceptions, fn exc ->
      String.match?(path, ~r/#{exc.context}/)
    end)
  end
end
```

## Integration with elegant-STATE

Category 12 results sync to elegant-STATE:

```graphql
mutation ReportLanguagePolicy($repo: String!, $result: PolicyResult!) {
  reportCategoryCompliance(
    repo: $repo
    category: 12
    result: $result
  ) {
    recorded
    timestamp
  }
}
```

## Version

Category 12 v1.0.0 (2025-12-09)
